
-- This script was generated by the ERD tool in pgAdmin 4.
-- Please log an issue at https://redmine.postgresql.org/projects/pgadmin4/issues/new if you find any bugs, including reproduction steps.
BEGIN;

-- Create the schema if it doesn't exist
CREATE SCHEMA IF NOT EXISTS u_flood;

CREATE EXTENSION IF NOT EXISTS postgis;

CREATE TABLE IF NOT EXISTS river_topo.edge_data
(
    edge_id integer NOT NULL DEFAULT nextval('river_topo.edge_data_edge_id_seq'::regclass),
    start_node integer NOT NULL,
    end_node integer NOT NULL,
    next_left_edge integer NOT NULL,
    abs_next_left_edge integer NOT NULL,
    next_right_edge integer NOT NULL,
    abs_next_right_edge integer NOT NULL,
    left_face integer NOT NULL,
    right_face integer NOT NULL,
    geom geometry,
    CONSTRAINT edge_data_pkey PRIMARY KEY (edge_id)
);

CREATE TABLE IF NOT EXISTS river_topo.face
(
    face_id integer NOT NULL DEFAULT nextval('river_topo.face_face_id_seq'::regclass),
    mbr geometry,
    CONSTRAINT face_primary_key PRIMARY KEY (face_id)
);

COMMENT ON TABLE river_topo.face
    IS 'Contains face topology primitives';

CREATE TABLE IF NOT EXISTS river_topo.node
(
    node_id integer NOT NULL DEFAULT nextval('river_topo.node_node_id_seq'::regclass),
    containing_face integer,
    geom geometry,
    CONSTRAINT node_primary_key PRIMARY KEY (node_id)
);

COMMENT ON TABLE river_topo.node
    IS 'Contains node topology primitives';

CREATE TABLE IF NOT EXISTS river_topo.relation
(
    topogeo_id integer NOT NULL,
    layer_id integer NOT NULL,
    element_id integer NOT NULL,
    element_type integer NOT NULL,
    CONSTRAINT relation_layer_id_topogeo_id_element_id_element_type_key UNIQUE (layer_id, topogeo_id, element_id, element_type)
);

CREATE TABLE IF NOT EXISTS river_topo.rivers
(
    identifier character varying(38) COLLATE pg_catalog."default" NOT NULL,
    topo topogeometry,
    CONSTRAINT rivers_pkey PRIMARY KEY (identifier)
);

CREATE TABLE IF NOT EXISTS river_topo.stations
(
    rloi_id integer,
    qualifier text COLLATE pg_catalog."default",
    topo topogeometry
);

CREATE TABLE IF NOT EXISTS u_flood.current_load_timestamp
(
    id integer NOT NULL,
    load_timestamp bigint,
    CONSTRAINT pk_current_load_timestamp PRIMARY KEY (id)
        USING INDEX TABLESPACE flood_indexes
);

CREATE TABLE IF NOT EXISTS u_flood.databasechangelog
(
    id character varying(255) COLLATE pg_catalog."default" NOT NULL,
    author character varying(255) COLLATE pg_catalog."default" NOT NULL,
    filename character varying(255) COLLATE pg_catalog."default" NOT NULL,
    dateexecuted timestamp without time zone NOT NULL,
    orderexecuted integer NOT NULL,
    exectype character varying(10) COLLATE pg_catalog."default" NOT NULL,
    md5sum character varying(35) COLLATE pg_catalog."default",
    description character varying(255) COLLATE pg_catalog."default",
    comments character varying(255) COLLATE pg_catalog."default",
    tag character varying(255) COLLATE pg_catalog."default",
    liquibase character varying(20) COLLATE pg_catalog."default",
    contexts character varying(255) COLLATE pg_catalog."default",
    labels character varying(255) COLLATE pg_catalog."default",
    deployment_id character varying(10) COLLATE pg_catalog."default"
);

CREATE TABLE IF NOT EXISTS u_flood.databasechangeloglock
(
    id integer NOT NULL,
    locked boolean NOT NULL,
    lockgranted timestamp without time zone,
    lockedby character varying(255) COLLATE pg_catalog."default",
    CONSTRAINT pk_databasechangeloglock PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS u_flood.england_010k
(
    gid integer NOT NULL DEFAULT nextval('england_010k_gid_seq'::regclass),
    region_id numeric,
    reg_name character varying(22) COLLATE pg_catalog."default",
    reg_prop_n character varying(24) COLLATE pg_catalog."default",
    reg_addr_1 character varying(25) COLLATE pg_catalog."default",
    reg_addr_2 character varying(25) COLLATE pg_catalog."default",
    reg_town character varying(22) COLLATE pg_catalog."default",
    reg_pcode character varying(20) COLLATE pg_catalog."default",
    geom geometry,
    CONSTRAINT england_010k_pkey PRIMARY KEY (gid)
);

CREATE TABLE IF NOT EXISTS u_flood.ffoi_max
(
    telemetry_id text COLLATE pg_catalog."default" NOT NULL,
    value numeric,
    value_date timestamp with time zone,
    filename text COLLATE pg_catalog."default",
    updated_date timestamp with time zone,
    CONSTRAINT pk_ffoi_max_telemetry_id PRIMARY KEY (telemetry_id)
        USING INDEX TABLESPACE flood_indexes
);

CREATE TABLE IF NOT EXISTS u_flood.ffoi_station
(
    ffoi_station_id bigint NOT NULL DEFAULT nextval('ffoi_station_ffoi_station_id_seq'::regclass),
    rloi_id integer NOT NULL,
    CONSTRAINT pk_ffoi_station_id PRIMARY KEY (ffoi_station_id)
        USING INDEX TABLESPACE flood_indexes
);

CREATE TABLE IF NOT EXISTS u_flood.ffoi_station_threshold
(
    ffoi_station_threshold_id bigint NOT NULL DEFAULT nextval('ffoi_station_threshold_ffoi_station_threshold_id_seq'::regclass),
    ffoi_station_id bigint NOT NULL,
    fwis_code text COLLATE pg_catalog."default" NOT NULL,
    value numeric NOT NULL,
    CONSTRAINT pk_ffoi_station_threshold_id PRIMARY KEY (ffoi_station_threshold_id)
        USING INDEX TABLESPACE flood_indexes
);

CREATE TABLE IF NOT EXISTS u_flood.flood_alert_area
(
    gid integer NOT NULL DEFAULT nextval('flood_alert_area_gid_seq'::regclass),
    area character varying(100) COLLATE pg_catalog."default",
    fws_tacode character varying(50) COLLATE pg_catalog."default",
    ta_name character varying(100) COLLATE pg_catalog."default",
    descrip character varying(254) COLLATE pg_catalog."default",
    la_name character varying(254) COLLATE pg_catalog."default",
    qdial character varying(50) COLLATE pg_catalog."default",
    river_sea character varying(254) COLLATE pg_catalog."default",
    geom geometry,
    CONSTRAINT flood_alert_area_pkey PRIMARY KEY (gid)
);

CREATE TABLE IF NOT EXISTS u_flood.flood_alert_area_2
(
    gid integer NOT NULL DEFAULT nextval('flood_alert_area_2_gid_seq'::regclass),
    area character varying(100) COLLATE pg_catalog."default",
    fws_tacode character varying(50) COLLATE pg_catalog."default",
    ta_name character varying(100) COLLATE pg_catalog."default",
    descrip character varying(254) COLLATE pg_catalog."default",
    la_name character varying(254) COLLATE pg_catalog."default",
    qdial character varying(50) COLLATE pg_catalog."default",
    river_sea character varying(254) COLLATE pg_catalog."default",
    geom geometry,
    CONSTRAINT flood_alert_area_2_pkey PRIMARY KEY (gid)
);

CREATE TABLE IF NOT EXISTS u_flood.flood_alert_area_20220223_backup
(
    gid integer,
    area character varying(100) COLLATE pg_catalog."default",
    fws_tacode character varying(50) COLLATE pg_catalog."default",
    ta_name character varying(100) COLLATE pg_catalog."default",
    descrip character varying(254) COLLATE pg_catalog."default",
    la_name character varying(254) COLLATE pg_catalog."default",
    qdial character varying(50) COLLATE pg_catalog."default",
    river_sea character varying(254) COLLATE pg_catalog."default",
    geom geometry
);

CREATE TABLE IF NOT EXISTS u_flood.flood_alert_area_20220511_backup
(
    gid integer,
    area character varying(100) COLLATE pg_catalog."default",
    fws_tacode character varying(50) COLLATE pg_catalog."default",
    ta_name character varying(100) COLLATE pg_catalog."default",
    descrip character varying(254) COLLATE pg_catalog."default",
    la_name character varying(254) COLLATE pg_catalog."default",
    qdial character varying(50) COLLATE pg_catalog."default",
    river_sea character varying(254) COLLATE pg_catalog."default",
    geom geometry
);

CREATE TABLE IF NOT EXISTS u_flood.flood_alert_area_valid
(
    area character varying(100) COLLATE pg_catalog."default",
    fws_tacode character varying(50) COLLATE pg_catalog."default",
    ta_name character varying(100) COLLATE pg_catalog."default",
    descrip character varying(254) COLLATE pg_catalog."default",
    la_name character varying(254) COLLATE pg_catalog."default",
    qdial character varying(50) COLLATE pg_catalog."default",
    river_sea character varying(254) COLLATE pg_catalog."default",
    geom geometry
);

CREATE TABLE IF NOT EXISTS u_flood.flood_warning_area
(
    gid integer NOT NULL DEFAULT nextval('flood_warning_area_gid_seq'::regclass),
    area character varying(100) COLLATE pg_catalog."default",
    fws_tacode character varying(50) COLLATE pg_catalog."default",
    ta_name character varying(100) COLLATE pg_catalog."default",
    descrip character varying(254) COLLATE pg_catalog."default",
    la_name character varying(254) COLLATE pg_catalog."default",
    parent character varying(50) COLLATE pg_catalog."default",
    qdial character varying(50) COLLATE pg_catalog."default",
    river_sea character varying(254) COLLATE pg_catalog."default",
    geom geometry,
    CONSTRAINT flood_warning_area_pkey PRIMARY KEY (gid)
);

CREATE TABLE IF NOT EXISTS u_flood.flood_warning_area_20220223_backup
(
    gid integer,
    area character varying(100) COLLATE pg_catalog."default",
    fws_tacode character varying(50) COLLATE pg_catalog."default",
    ta_name character varying(100) COLLATE pg_catalog."default",
    descrip character varying(254) COLLATE pg_catalog."default",
    la_name character varying(254) COLLATE pg_catalog."default",
    parent character varying(50) COLLATE pg_catalog."default",
    qdial character varying(50) COLLATE pg_catalog."default",
    river_sea character varying(254) COLLATE pg_catalog."default",
    geom geometry
);

CREATE TABLE IF NOT EXISTS u_flood.flood_warning_area_20220511_backup
(
    gid integer,
    area character varying(100) COLLATE pg_catalog."default",
    fws_tacode character varying(50) COLLATE pg_catalog."default",
    ta_name character varying(100) COLLATE pg_catalog."default",
    descrip character varying(254) COLLATE pg_catalog."default",
    la_name character varying(254) COLLATE pg_catalog."default",
    parent character varying(50) COLLATE pg_catalog."default",
    qdial character varying(50) COLLATE pg_catalog."default",
    river_sea character varying(254) COLLATE pg_catalog."default",
    geom geometry
);

CREATE TABLE IF NOT EXISTS u_flood.fwis
(
    id bigint NOT NULL DEFAULT nextval('fwis_id_seq'::regclass),
    situation text COLLATE pg_catalog."default",
    ta_id integer,
    ta_code character varying(200) COLLATE pg_catalog."default",
    ta_name text COLLATE pg_catalog."default",
    ta_description text COLLATE pg_catalog."default",
    quick_dial integer,
    ta_version integer,
    ta_category character varying(200) COLLATE pg_catalog."default",
    owner_area character varying(200) COLLATE pg_catalog."default",
    ta_created_date timestamp with time zone,
    ta_modified_date timestamp with time zone,
    situation_changed timestamp with time zone,
    severity_changed timestamp with time zone,
    message_received timestamp with time zone,
    severity_value integer,
    severity character varying(200) COLLATE pg_catalog."default",
    CONSTRAINT fwis_pkey PRIMARY KEY (id)
        USING INDEX TABLESPACE flood_indexes
);

CREATE TABLE IF NOT EXISTS u_flood.impact
(
    id bigint NOT NULL DEFAULT nextval('impact_id_seq'::regclass),
    rloi_id integer NOT NULL,
    value numeric,
    units text COLLATE pg_catalog."default",
    comment text COLLATE pg_catalog."default",
    short_name text COLLATE pg_catalog."default",
    description text COLLATE pg_catalog."default",
    type text COLLATE pg_catalog."default",
    obs_flood_year text COLLATE pg_catalog."default",
    obs_flood_month text COLLATE pg_catalog."default",
    source text COLLATE pg_catalog."default",
    lat numeric,
    lng numeric,
    geom geometry,
    CONSTRAINT impact_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS u_flood.imtd_niki
(
    station_threshold_id bigint NOT NULL DEFAULT nextval('station_imtd_threshold_station_threshold_id_seq'::regclass),
    station_id bigint NOT NULL,
    fwis_code text COLLATE pg_catalog."default" NOT NULL,
    fwis_type character(1) COLLATE pg_catalog."default" NOT NULL,
    direction character(1) COLLATE pg_catalog."default" NOT NULL,
    value numeric NOT NULL,
    CONSTRAINT pk_station_imtd_threshold PRIMARY KEY (station_threshold_id)
        USING INDEX TABLESPACE flood_indexes
);

CREATE TABLE IF NOT EXISTS u_flood.river
(
    id character varying(200) COLLATE pg_catalog."default" NOT NULL,
    name character varying(200) COLLATE pg_catalog."default",
    qualified_name character varying(250) COLLATE pg_catalog."default",
    CONSTRAINT river_pkey PRIMARY KEY (id)
);

CREATE TABLE IF NOT EXISTS u_flood.river_display
(
    id integer,
    local_name character varying COLLATE pg_catalog."default",
    qualified_name character varying COLLATE pg_catalog."default",
    river_id character varying COLLATE pg_catalog."default"
);

CREATE TABLE IF NOT EXISTS u_flood.river_display_name
(
    river_id text COLLATE pg_catalog."default",
    display text COLLATE pg_catalog."default"
);

CREATE TABLE IF NOT EXISTS u_flood.river_stations
(
    river_id character varying(200) COLLATE pg_catalog."default",
    rloi_id integer,
    rank integer
);

CREATE TABLE IF NOT EXISTS u_flood.river_stations_list_test
(
    id character varying(200) COLLATE pg_catalog."default",
    name character varying(200) COLLATE pg_catalog."default",
    rloi_id integer,
    rank integer,
    display_name text COLLATE pg_catalog."default"
);

CREATE TABLE IF NOT EXISTS u_flood.sls_telemetry_station
(
    telemetry_station_id bigint NOT NULL DEFAULT nextval('sls_telemetry_station_id_seq'::regclass),
    station_reference text COLLATE pg_catalog."default" NOT NULL,
    region text COLLATE pg_catalog."default",
    station_name text COLLATE pg_catalog."default",
    ngr character varying(50) COLLATE pg_catalog."default",
    easting integer,
    northing integer,
    CONSTRAINT pk_sls_telemetry_station_id PRIMARY KEY (telemetry_station_id)
        USING INDEX TABLESPACE flood_indexes,
    CONSTRAINT unique_station UNIQUE (station_reference, region)
        USING INDEX TABLESPACE flood_indexes
);

CREATE TABLE IF NOT EXISTS u_flood.sls_telemetry_value
(
    telemetry_value_id bigint NOT NULL DEFAULT nextval('sls_telemetry_value_telemetry_value_id_seq'::regclass),
    telemetry_value_parent_id bigint NOT NULL,
    value numeric,
    processed_value numeric,
    value_timestamp timestamp with time zone NOT NULL,
    error boolean NOT NULL,
    CONSTRAINT pk_sls_telemetry_value_id PRIMARY KEY (telemetry_value_id)
        USING INDEX TABLESPACE flood_indexes
);

CREATE TABLE IF NOT EXISTS u_flood.sls_telemetry_value_parent
(
    telemetry_value_parent_id bigint NOT NULL DEFAULT nextval('sls_telemetry_value_parent_telemetry_value_parent_id_seq'::regclass),
    filename text COLLATE pg_catalog."default" NOT NULL,
    imported timestamp with time zone NOT NULL,
    rloi_id integer NOT NULL,
    station text COLLATE pg_catalog."default" NOT NULL,
    region text COLLATE pg_catalog."default" NOT NULL,
    start_timestamp timestamp with time zone NOT NULL,
    end_timestamp timestamp with time zone NOT NULL,
    parameter text COLLATE pg_catalog."default" NOT NULL,
    qualifier text COLLATE pg_catalog."default",
    units text COLLATE pg_catalog."default" NOT NULL,
    post_process boolean,
    subtract numeric(6, 3),
    por_max_value numeric(6, 3),
    station_type character(1) COLLATE pg_catalog."default",
    percentile_5 numeric(6, 3),
    data_type text COLLATE pg_catalog."default",
    period text COLLATE pg_catalog."default",
    CONSTRAINT pk_sls_telemetry_value_parent_id PRIMARY KEY (telemetry_value_parent_id)
        USING INDEX TABLESPACE flood_indexes
);

CREATE TABLE IF NOT EXISTS u_flood.station_imtd_threshold
(
    station_threshold_id bigint NOT NULL DEFAULT nextval('station_imtd_threshold_station_threshold_id_seq'::regclass),
    station_id bigint NOT NULL,
    fwis_code text COLLATE pg_catalog."default" NOT NULL,
    fwis_type character(1) COLLATE pg_catalog."default" NOT NULL,
    direction character(1) COLLATE pg_catalog."default" NOT NULL,
    value numeric NOT NULL,
    CONSTRAINT pk_station_imtd_threshold_id PRIMARY KEY (station_threshold_id)
        USING INDEX TABLESPACE flood_indexes
);

CREATE TABLE IF NOT EXISTS u_flood.station_ta_8km
(
    rloi_id integer,
    fws_tacode text COLLATE pg_catalog."default"
);

CREATE TABLE IF NOT EXISTS u_flood.station_ta_8km_2
(
    rloi_id integer,
    fws_tacode text COLLATE pg_catalog."default"
);

CREATE TABLE IF NOT EXISTS u_flood.station_ta_8km_20220223_backup
(
    rloi_id integer,
    fws_tacode text COLLATE pg_catalog."default"
);

CREATE TABLE IF NOT EXISTS u_flood.station_ta_8km_20220512_backup
(
    rloi_id integer,
    fws_tacode text COLLATE pg_catalog."default"
);

CREATE TABLE IF NOT EXISTS u_flood.station_ta_8km_20220512_test_run
(
    rloi_id integer,
    fws_tacode text COLLATE pg_catalog."default"
);

CREATE TABLE IF NOT EXISTS u_flood.telemetry_context
(
    telemetry_context_id bigint NOT NULL DEFAULT nextval('telemetry_context_telemetry_context_id_seq'::regclass),
    telemetry_id text COLLATE pg_catalog."default",
    wiski_id text COLLATE pg_catalog."default",
    rloi_id integer,
    station_type character(1) COLLATE pg_catalog."default",
    post_process boolean,
    subtract numeric,
    region text COLLATE pg_catalog."default",
    area text COLLATE pg_catalog."default",
    catchment text COLLATE pg_catalog."default",
    display_region text COLLATE pg_catalog."default",
    display_area text COLLATE pg_catalog."default",
    display_catchment text COLLATE pg_catalog."default",
    agency_name text COLLATE pg_catalog."default",
    external_name text COLLATE pg_catalog."default",
    location_info text COLLATE pg_catalog."default",
    x_coord_actual integer,
    y_coord_actual integer,
    actual_ngr text COLLATE pg_catalog."default",
    x_coord_display integer,
    y_coord_display integer,
    site_max numeric,
    wiski_river_name text COLLATE pg_catalog."default",
    date_open date,
    stage_datum numeric,
    period_of_record text COLLATE pg_catalog."default",
    por_max_value numeric,
    date_por_max timestamp with time zone,
    highest_level numeric,
    date_highest_level timestamp with time zone,
    por_min_value numeric,
    date_por_min timestamp with time zone,
    percentile_5 numeric,
    percentile_95 numeric,
    comments text COLLATE pg_catalog."default",
    d_stage_datum numeric,
    d_period_of_record text COLLATE pg_catalog."default",
    d_por_max_value numeric,
    d_date_por_max timestamp with time zone,
    d_highest_level numeric,
    d_date_highest_level timestamp with time zone,
    d_por_min_value numeric,
    d_date_por_min timestamp with time zone,
    d_percentile_5 numeric,
    d_percentile_95 numeric,
    d_comments text COLLATE pg_catalog."default",
    status text COLLATE pg_catalog."default",
    status_reason text COLLATE pg_catalog."default",
    status_date timestamp with time zone,
    CONSTRAINT pk_telemetry_context PRIMARY KEY (telemetry_context_id)
        USING INDEX TABLESPACE flood_indexes
);

CREATE TABLE IF NOT EXISTS u_flood.time_series_region_lkp
(
    time_series_lkp_id bigint NOT NULL DEFAULT nextval('time_series_region_lkp_time_series_lkp_id_seq'::regclass),
    region_name text COLLATE pg_catalog."default" NOT NULL,
    context_region_name text COLLATE pg_catalog."default" NOT NULL,
    CONSTRAINT pk_time_series_region_lkp PRIMARY KEY (time_series_lkp_id)
        USING INDEX TABLESPACE flood_indexes,
    CONSTRAINT uc_context_region_name UNIQUE (context_region_name)
        USING INDEX TABLESPACE flood_indexes,
    CONSTRAINT uc_region_name UNIQUE (region_name)
        USING INDEX TABLESPACE flood_indexes
);

ALTER TABLE IF EXISTS river_topo.edge_data
    ADD CONSTRAINT end_node_exists FOREIGN KEY (end_node)
    REFERENCES river_topo.node (node_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS edge_end_node_idx
    ON river_topo.edge_data(end_node);


ALTER TABLE IF EXISTS river_topo.edge_data
    ADD CONSTRAINT left_face_exists FOREIGN KEY (left_face)
    REFERENCES river_topo.face (face_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS edge_left_face_idx
    ON river_topo.edge_data(left_face);


ALTER TABLE IF EXISTS river_topo.edge_data
    ADD CONSTRAINT next_left_edge_exists FOREIGN KEY (abs_next_left_edge)
    REFERENCES river_topo.edge_data (edge_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION
    DEFERRABLE INITIALLY DEFERRED;


ALTER TABLE IF EXISTS river_topo.edge_data
    ADD CONSTRAINT next_right_edge_exists FOREIGN KEY (abs_next_right_edge)
    REFERENCES river_topo.edge_data (edge_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION
    DEFERRABLE INITIALLY DEFERRED;


ALTER TABLE IF EXISTS river_topo.edge_data
    ADD CONSTRAINT right_face_exists FOREIGN KEY (right_face)
    REFERENCES river_topo.face (face_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS edge_right_face_idx
    ON river_topo.edge_data(right_face);


ALTER TABLE IF EXISTS river_topo.edge_data
    ADD CONSTRAINT start_node_exists FOREIGN KEY (start_node)
    REFERENCES river_topo.node (node_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;
CREATE INDEX IF NOT EXISTS edge_start_node_idx
    ON river_topo.edge_data(start_node);


ALTER TABLE IF EXISTS river_topo.node
    ADD CONSTRAINT face_exists FOREIGN KEY (containing_face)
    REFERENCES river_topo.face (face_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE NO ACTION;


ALTER TABLE IF EXISTS u_flood.ffoi_station_threshold
    ADD CONSTRAINT fk_ffoi_station_id FOREIGN KEY (ffoi_station_id)
    REFERENCES u_flood.ffoi_station (ffoi_station_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;


ALTER TABLE IF EXISTS u_flood.sls_telemetry_value
    ADD CONSTRAINT fk_sls_telemetry_value_parent_id FOREIGN KEY (telemetry_value_parent_id)
    REFERENCES u_flood.sls_telemetry_value_parent (telemetry_value_parent_id) MATCH SIMPLE
    ON UPDATE NO ACTION
    ON DELETE CASCADE;
CREATE INDEX IF NOT EXISTS idx_sls_tv_telemetry_value_parent_id
    ON u_flood.sls_telemetry_value(telemetry_value_parent_id);

END;